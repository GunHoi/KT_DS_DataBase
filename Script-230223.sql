-- 104. 가장 많은 사원이 있는 부서의 국가명을 조회한다.
-- 가장 많은 사원이 있는 부서

;
-- 부서의 국가명
SELECT COU.COUNTRY_NAME
  FROM COUNTRIES COU
 WHERE COU.COUNTRY_ID IN (SELECT LOC.COUNTRY_ID 
 						    FROM LOCATIONS LOC
 						   WHERE LOC.LOCATION_ID IN (SELECT DEP.LOCATION_ID 
 						   							   FROM DEPARTMENTS DEP
 						   							  WHERE DEP.DEPARTMENT_NAME = (SELECT DEPARTMENT_NAME
																					 FROM (SELECT DEPARTMENT_NAME
																							    , CNT
																							 FROM (SELECT COUNT(EMP.EMPLOYEE_ID) CNT
																									    , DEP.DEPARTMENT_NAME 
																									 FROM DEPARTMENTS DEP
																									 JOIN EMPLOYEES EMP
																									   ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
																									GROUP BY DEPARTMENT_NAME)
																							ORDER BY CNT DESC)
																					WHERE ROWNUM <= 1)))
;
-- 105. 우편번호가 5자리인 도시에서 근무하는 사원명, 부서명, 도시명, 우편번호를 조회한다.
-- 우편번호가 5자리인 도시
SELECT EMP.FIRST_NAME 
     , DEP.DEPARTMENT_NAME 
     , LOC.CITY
     , LOC.POSTAL_CODE
  FROM LOCATIONS LOC
  JOIN DEPARTMENTS DEP
    ON LOC.LOCATION_ID = DEP.LOCATION_ID 
  JOIN EMPLOYEES EMP
    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
 WHERE POSTAL_CODE LIKE '_____'
;
-- 106. 우편번호에 공백이 없는 도시에서 근무하는 사원의 이름, 부서명, 우편번호를 조회한다.
-- 우편번호에 공백이 없는 도시
SELECT EMP.FIRST_NAME 
     , DEP.DEPARTMENT_NAME 
     , LOC.POSTAL_CODE
  FROM LOCATIONS LOC
  JOIN DEPARTMENTS DEP
    ON LOC.LOCATION_ID = DEP.LOCATION_ID
  JOIN EMPLOYEES EMP
    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
 WHERE LOC.POSTAL_CODE NOT LIKE '% %'
;
-- 107. "주"가 없는 도시에서 근무하는 사원의 이름, 도시를 조회한다.
-- "주"가 없는 도시
SELECT EMP.FIRST_NAME 
     , LOC.CITY
  FROM LOCATIONS LOC
  JOIN DEPARTMENTS DEP
    ON LOC.LOCATION_ID = DEP.LOCATION_ID
  JOIN EMPLOYEES EMP
    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
 WHERE LOC.STATE_PROVINCE IS NULL
;
-- 108. 국가명이 6자리인 국가의 모든 정보를 조회한다.
-- 국가명이 6자리
SELECT *
  FROM COUNTRIES COU
 WHERE COU.COUNTRY_NAME LIKE '______'
;

SELECT *
  FROM (SELECT LENGTH(COU.COUNTRY_NAME) LEN_COUNTRY_NAME
             , COU.*
  		  FROM COUNTRIES COU)
 WHERE LEN_COUNTRY_NAME = 6
;
-- 109. 사원의 이름과 성을 이용해 EMAIL과 같은 값으로 만들어 조회한다.
SELECT SUBSTR(FIRST_NAME, 1, 1) || UPPER(LAST_NAME) 
     , EMAIL
  FROM EMPLOYEES 
;
-- 110. 모든 사원들의 이름을 10자리로 변환해 조회한다. 예> 이름 => "        이름"
SELECT LPAD(FIRST_NAME, 10, ' ')
     , LPAD(FIRST_NAME, 10)
  FROM EMPLOYEES
;
-- 111. 모든 사원들의 성을 10자리로 변환해 조회한다. 예> 성 => "성         "
SELECT RPAD(LAST_NAME, 10, ' ')
     , RPAD(LAST_NAME, 10)
  FROM EMPLOYEES
;
-- 112. 109번 사원의 입사일 부터 1년 내에 입사한 사원의 모든 정보를 조회한다.
-- 109번 사원의 입사일
SELECT HIRE_DATE HD_109
     , ADD_MONTHS(HIRE_DATE, 12) HD_109_PLUS1Y 
  FROM EMPLOYEES 
 WHERE EMPLOYEE_ID = 109
;

SELECT *
  FROM EMPLOYEES EMP
     , (SELECT HIRE_DATE HD_109
		     , ADD_MONTHS(HIRE_DATE, 12) HD_109_PLUS1Y 
		  FROM EMPLOYEES 
		 WHERE EMPLOYEE_ID = 109) EMP_109_HIRE
 WHERE HIRE_DATE BETWEEN EMP_109_HIRE.HD_109 AND EMP_109_HIRE.HD_109_PLUS1Y
;

-- 강사님이 알려주신 코드
--WITH [별칭] AS (SQL)
--SELECT *
--  FROM 별칭
WITH HIRE_DATE_109 AS (SELECT HIRE_DATE
						 FROM EMPLOYEES 
						WHERE EMPLOYEE_ID = 109)
SELECT *
  FROM EMPLOYEES 
 WHERE HIRE_DATE BETWEEN (SELECT HIRE_DATE
 							FROM HIRE_DATE_109) AND (SELECT ADD_MONTHS(HIRE_DATE, 12)
 							                           FROM HIRE_DATE_109)
;


-- 113. 가장 먼저 입사한 사원의 입사일로부터 2년 내에 입사한 사원의 모든 정보를 조회한다.
-- 가장 먼저 입사한 사원
SELECT HIRE_DATE
  FROM (SELECT HIRE_DATE
		  FROM EMPLOYEES
		 ORDER BY HIRE_DATE ASC)
 WHERE ROWNUM <= 1
;

SELECT *
  FROM EMPLOYEES EMP
     , (SELECT HIRE_DATE
		  FROM (SELECT HIRE_DATE
				  FROM EMPLOYEES
				 ORDER BY HIRE_DATE ASC)
		 WHERE ROWNUM <= 1) EMP_FIRST
 WHERE EMP.HIRE_DATE BETWEEN EMP_FIRST.HIRE_DATE AND ADD_MONTHS(EMP_FIRST.HIRE_DATE, 24) 
;

-- WITH 사용
WITH HIRE_DATE_FIRST AS (SELECT HIRE_DATE
						 FROM (SELECT HIRE_DATE
							     FROM EMPLOYEES
								ORDER BY HIRE_DATE ASC)
						WHERE ROWNUM <= 1)
SELECT *
  FROM EMPLOYEES 
 WHERE HIRE_DATE BETWEEN (SELECT HIRE_DATE
 							FROM HIRE_DATE_FIRST) AND (SELECT ADD_MONTHS(HIRE_DATE, 24)
 							                             FROM HIRE_DATE_FIRST)
;
WITH FIRST_HIRE_DATE AS (SELECT HIRE_DATE
                              , ADD_MONTHS(HIRE_DATE, 24) AFTER_TWO_YEAR
                           FROM EMPLOYEES
                          WHERE HIRE_DATE = (SELECT MIN(HIRE_DATE)
                                               FROM EMPLOYEES))
SELECT *
  FROM EMPLOYEES
 WHERE HIRE_DATE >= (SELECT HIRE_DATE
 					   FROM FIRST_HIRE_DATE)
   AND HIRE_DATE <= (SELECT AFTER_TWO_YEAR
   					   FROM FIRST_HIRE_DATE)
;

-- 114. 가장 늦게 입사한 사원의 입사일 보다 1년 앞서 입사한 사원의 모든 정보를 조회한다.
-- 가장 늦게 입사한 사원
SELECT *
  FROM (SELECT HIRE_DATE
		  FROM EMPLOYEES 
		 ORDER BY HIRE_DATE DESC)
 WHERE ROWNUM < 2
;

SELECT *
  FROM EMPLOYEES EMP
     , (SELECT *
		  FROM (SELECT HIRE_DATE
				  FROM EMPLOYEES 
				 ORDER BY HIRE_DATE DESC)
		 WHERE ROWNUM < 2) EMP_LAST
 WHERE EMP.HIRE_DATE BETWEEN ADD_MONTHS(EMP_LAST.HIRE_DATE, -12) AND EMP_LAST.HIRE_DATE
;

SELECT *
  FROM EMPLOYEES E1
     , EMPLOYEES E2
;

--WITH 별칭1 AS (SELECT ...)
--   , 별칭2 AS (SELECT ...)
--   , 별칭3 AS (SELECT ...)
--SELECT *
--  FROM 별칭1
--  JOIN 별칭2
--    ON ...
--------------
--SELECT *
--  FROM 별칭1
-- WHERE COL = (SELECT COL FROM 별칭2)

-- 115. 도시명에 띄어쓰기 " " 가 포함된 도시에서 근무중인 사원들의 부서명, 도시명, 사원명을 조회한다.
SELECT DEP.DEPARTMENT_NAME
     , LOC.CITY 
     , EMP.FIRST_NAME
  FROM LOCATIONS LOC
  JOIN DEPARTMENTS DEP
    ON LOC.LOCATION_ID = DEP.LOCATION_ID
  JOIN EMPLOYEES EMP
    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID 
 WHERE LOC.CITY LIKE '% %'
;
-- 116. MOD 함수를 통해 사원번호가 홀수면 남자, 짝수면 여자 로 구분해 조회한다. MOD(값, 나눌값)
SELECT EMPLOYEE_ID
     , CASE MOD(EMPLOYEE_ID, 2)
     	 WHEN 1 THEN
     	   '남자'
     	 WHEN 0 THEN
     	   '여자'
     	 ELSE
     	   'NULL'
     END SEX
  FROM EMPLOYEES
;

SELECT EMPLOYEE_ID
     , DECODE(MOD(EMPLOYEE_ID,2)
            , 1, '남자'
            , 0, '여자'
            , 'NULL') SEX
  FROM EMPLOYEES EMP
;
-- 117. '20230222' 문자 데이터를 날짜로 변환해 조회한다. (DUAL)
SELECT TO_DATE('20230222')
  FROM DUAL 
;
-- 118. '20230222' 문자 데이터를 'YYYY-MM' 으로 변환해 조회한다. (DUAL)
SELECT TO_CHAR(TO_DATE('20230222', 'YYYY-MM-DD'), 'YYYY-MM')
  FROM DUAL 
;
-- 119. '20230222130140' 문자 데이터를 'YYYY-MM-DD HH24:MI:SS' 으로 변환해 조회한다. (DUAL)
SELECT TO_DATE('20230222130140', 'YYYY-MM-DD HH24:MI:SS')
  FROM DUAL 
;
-- 120. '20230222' 날짜의 열흘 후의 날짜를 'YYYY-MM-DD' 으로 변환해 조회한다. (DUAL)
SELECT TO_DATE('20230222', 'YYYY-MM-DD')+10
  FROM DUAL 
;
-- 121. 사원 이름의 글자수 별 사원의 수를 조회한다.
SELECT LENGTH(FIRST_NAME)
     , COUNT(EMPLOYEE_ID)
  FROM EMPLOYEES
 GROUP BY(LENGTH (FIRST_NAME))
;

SELECT NAME_LEN
     , COUNT(1)
  FROM (SELECT LENGTH(FIRST_NAME) NAME_LEN
  		  FROM EMPLOYEES)
 GROUP BY NAME_LEN
;
-- 122. 사원 성의 글자수 별 사원의 수를 조회한다.
SELECT LENGTH(LAST_NAME)
     , COUNT(EMPLOYEE_ID)
  FROM EMPLOYEES
 GROUP BY(LENGTH (LAST_NAME))
;
SELECT NAME_LEN
     , COUNT(1)
  FROM (SELECT LENGTH(LAST_NAME) NAME_LEN
	      FROM EMPLOYEES)
 GROUP BY NAME_LEN
;
-- 123. 사원의 연봉이 5000 이하이면 "사원", 7000 이하이면 "대리", 9000 이하이면 "과장", 그 외에는 임원 으로 조회한다.
SELECT SALARY
     , CASE 
  		 WHEN SALARY <= 5000 THEN
	  	   '사원'
  		 WHEN SALARY <= 7000 THEN
  	  	   '대리'
  		 WHEN SALARY <= 9000 THEN
  	  	   '과장'
  		 ELSE 
  	  	   '임원'
       END "POSITIONS"
  FROM EMPLOYEES E
;
-- 124. 부서별 사원의 수를 조인을 이용해 다음과 같이 조회한다. "부서명 (사원의 수)"
SELECT DEP.DEPARTMENT_NAME || ' (' || EMP.EMP_CNT || ')'
  FROM DEPARTMENTS DEP
  JOIN (SELECT DEPARTMENT_ID
		     , COUNT(EMPLOYEE_ID) EMP_CNT
		  FROM EMPLOYEES
		 GROUP BY DEPARTMENT_ID) EMP
    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
;
-- 125. 부서별 사원의 수를 스칼라쿼리를 이용해 다음과 같이 조회한다. "부서명 (사원의 수)"
SELECT DEP.DEPARTMENT_NAME
    || ' ('
    || (SELECT COUNT(EMPLOYEE_ID) EMP_CNT
		  FROM EMPLOYEES
		 WHERE DEP.DEPARTMENT_ID = DEPARTMENT_ID)
	|| ')'
  FROM DEPARTMENTS DEP
;
-- 126. 사원의 정보를 다음과 같이 조회한다. "사원번호 번 사원의 이름은 성이름 입니다."
SELECT EMPLOYEE_ID
    || '번 사원의 이름은 '
    || LAST_NAME 
    || FIRST_NAME
    || ' 입니다.'
  FROM EMPLOYEES
;
-- 127. 사원의 정보를 스칼라쿼리를 이용해 다음과 같이 조회한다. "사원번호 번 사원의 상사명은 상사명 입니다."
SELECT EMPLOYEE_ID
    || '번 사원의 상사명은 '
    || (SELECT MAN.FIRST_NAME
     	  FROM EMPLOYEES MAN
     	 WHERE EMP.MANAGER_ID = MAN.EMPLOYEE_ID)
    || ' 입니다.' 
  FROM EMPLOYEES EMP
 WHERE EMP.MANAGER_ID IS NOT NULL
;
-- 128. 사원의 정보를 조인을 이용해 다음고 같이 조회한다. "사원명 (직무명)"
SELECT EMP.FIRST_NAME || ' (' || DEP.DEPARTMENT_NAME || ')'
  FROM EMPLOYEES EMP
  JOIN DEPARTMENTS DEP	
    ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID 
;
-- 129. 사원의 정보를 스칼라쿼리를 이용해 다음과 같이 조회한다. "사원명 (직무명)"
SELECT EMP.FIRST_NAME 
    || ' ('
    || (SELECT DEP.DEPARTMENT_NAME 
     	  FROM DEPARTMENTS DEP
     	 WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID)
    || ')'
  FROM EMPLOYEES EMP
;
-- 130. 부서별 연봉 차이(최고연봉 - 최저연봉)가 가장 큰 부서명을 조회한다.
-- 부서별 연봉 차이(최고연봉 - 최저연봉)
SELECT DEP.DEPARTMENT_NAME 
     , MAX(EMP.SALARY) - MIN(EMP.SALARY)
  FROM DEPARTMENTS DEP
  JOIN EMPLOYEES EMP
    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
 GROUP BY DEP.DEPARTMENT_NAME
;
-- 가장 큰 부서명
SELECT DEPARTMENT_NAME
     , SALARY_DIFF
  FROM (SELECT DEPARTMENT_NAME
             , SALARY_DIFF
		  FROM (SELECT DEP.DEPARTMENT_NAME 
				     , MAX(EMP.SALARY) - MIN(EMP.SALARY) SALARY_DIFF
				  FROM DEPARTMENTS DEP
				  JOIN EMPLOYEES EMP
				    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
				 GROUP BY DEP.DEPARTMENT_NAME) 
		 ORDER BY SALARY_DIFF DESC)
 WHERE ROWNUM < 2
;
-- 131. 부서별 연봉 차이(최고연봉 - 최저연봉)가 가장 큰 부서에서 근무하는 사원들의 직무명을 중복없이 조회한다.
SELECT DISTINCT JOB.JOB_TITLE
  FROM (SELECT DEPARTMENT_ID
		  FROM (SELECT DEPARTMENT_ID
		             , SALARY_DIFF
				  FROM (SELECT DEP.DEPARTMENT_ID 
						     , MAX(EMP.SALARY) - MIN(EMP.SALARY) SALARY_DIFF
						  FROM DEPARTMENTS DEP
						  JOIN EMPLOYEES EMP
						    ON DEP.DEPARTMENT_ID = EMP.DEPARTMENT_ID
						 GROUP BY DEP.DEPARTMENT_ID) 
				 ORDER BY SALARY_DIFF DESC)
		 WHERE ROWNUM < 2) DEP_MAX_SAL_DIFF
  JOIN EMPLOYEES EMP
    ON DEP_MAX_SAL_DIFF.DEPARTMENT_ID = EMP.DEPARTMENT_ID
  JOIN JOBS JOB
    ON EMP.JOB_ID = JOB.JOB_ID 
;
-- 132. 부서장이 없는 부서명 중 첫 글자가 'C' 로 시작하는 부서명을 조회한다.
-- 부서장이 없는 부서명
SELECT DEPARTMENT_NAME 
  FROM DEPARTMENTS
 WHERE MANAGER_ID IS NULL
   AND DEPARTMENT_NAME LIKE 'C%'
;
-- 133. 부서장이 있는 부서명 중 첫 글자가 'S' 로 시작하는 부서에서 근무중인 사원의 이름과 직무명, 부서명을 조회한다.
SELECT EMP.FIRST_NAME 
     , JOB.JOB_TITLE
     , DEP.DEPARTMENT_NAME 
  FROM DEPARTMENTS DEP
  JOIN EMPLOYEES EMP
    ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID
  JOIN JOBS JOB
    ON EMP.JOB_ID = JOB.JOB_ID 
 WHERE DEP.MANAGER_ID IS NOT NULL
   AND DEP.DEPARTMENT_NAME LIKE 'S%'
;
-- 134. 지역변호가 1000 ~ 1999 사이인 지역의 부서의 모든 정보를 조회한다.
SELECT *
  FROM DEPARTMENTS DEP
 WHERE DEP.LOCATION_ID IN (SELECT LOC.LOCATION_ID 
						     FROM LOCATIONS LOC
						    WHERE LOC.LOCATION_ID BETWEEN 1000 AND 1999)
;
-- 135. 90, 60, 100번 부서에서 근무중인 사원의 이름, 성, 부서명을 조회한다.
-- 90, 60, 100번 부서
SELECT FIRST_NAME
     , LAST_NAME 
     , DEP.DEPARTMENT_NAME 
  FROM EMPLOYEES EMP
  JOIN (SELECT DEPARTMENT_ID 
             , DEPARTMENT_NAME
		  FROM DEPARTMENTS
		 WHERE DEPARTMENT_ID IN (90, 60, 100)) DEP
    ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID 
;
-- 136. 부서명이 5글자 미만인 부서에서 근무중인 사원의 이름, 부서명을 조회한다.
-- 부서명이 5글자 미만
SELECT EMP.FIRST_NAME 
     , DEP.DEPARTMENT_NAME 
  FROM (SELECT LENGTH(DEPARTMENT_NAME) DEPNAME_LEN
		     , DEPARTMENT_NAME
		     , DEPARTMENT_ID 
		  FROM DEPARTMENTS) DEP
  JOIN EMPLOYEES EMP
    ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID
 WHERE DEP.DEPNAME_LEN < 5
;
-- 137. 국가 아이디가 'C'로 시작하는 국가의 지역을 모두 조회한다.
SELECT *
  FROM LOCATIONS LOC
 WHERE LOC.COUNTRY_ID IN (SELECT COUNTRY_ID
						    FROM COUNTRIES
						   WHERE COUNTRY_NAME LIKE 'C%')
;
-- 138. 국가 아이디의 첫 글자와 국가명의 첫 글자가 다른 모든 국가를 조회한다.
-- 국가 아이디의 첫글자
SELECT *
  FROM (SELECT SUBSTR(COUNTRY_ID, 1, 1) CID
		     , SUBSTR(COUNTRY_NAME, 1, 1) CNA
		     , COU.*
		  FROM COUNTRIES COU)
 WHERE CID != CNA
;
-- 139. 사원 모든 정보 중 이메일만 모두 소문자로 조회하여 조회한다.
SELECT EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , LOWER(EMAIL) EMAIL
	 , PHONE_NUMBER
	 , HIRE_DATE
	 , JOB_ID
	 , SALARY
	 , COMMISSION_PCT
	 , MANAGER_ID
	 , DEPARTMENT_ID
  FROM EMPLOYEES
;
-- 140. 사원의 연봉을 TRUNC(소수점 버림) 함수를 사용해 100 단위는 버린채 다음과 같이 조회한다.  예> 3700 -> 3000, 12700 -> 12000
SELECT SALARY
     , TRUNC(SALARY, -3)
     , TRUNC(SALARY/1000)*1000
  FROM EMPLOYEES
;
-- 141. 100단위를 버린 사원의 연봉 별 사원의 수를 조회한다.
SELECT SAL
     , COUNT(1)
  FROM (SELECT TRUNC(SALARY, -3) SAL
		     , PHONE_NUMBER
		     , MANAGER_ID
		     , LAST_NAME
		     , JOB_ID
		     , HIRE_DATE
		     , FIRST_NAME
		     , EMPLOYEE_ID
		     , EMAIL
		     , DEPARTMENT_ID
		     , COMMISSION_PCT
		  FROM EMPLOYEES)
 GROUP BY SAL 
;

SELECT 
-- 142. 현재 시간으로부터 20년 전 보다 일찍 입사한 사원의 모든 정보를 조회한다.
SELECT *
  FROM EMPLOYEES 
 WHERE HIRE_DATE < ADD_MONTHS(SYSDATE, -12*20)
;
-- 143. 부서번호별 현재 시간으로부터 15년 전 보다 일찍 입사한 사원의 수를 조회한다.
SELECT DEPARTMENT_ID
     , COUNT(1)
  FROM EMPLOYEES 
 WHERE HIRE_DATE < ADD_MONTHS(SYSDATE, -12*15)
 GROUP BY DEPARTMENT_ID
;
 
-- 144. 부서명, 직무명 별 평균 연봉을 조회한다.
SELECT DEP.DEPARTMENT_NAME 
     , JOB.JOB_TITLE
     , AVG(EMP.SALARY)
  FROM EMPLOYEES EMP
  JOIN DEPARTMENTS DEP
    ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID 
  JOIN JOBS JOB
    ON JOB.JOB_ID = EMP.JOB_ID
 GROUP BY DEP.DEPARTMENT_NAME 
     , JOB.JOB_TITLE
;
-- 145. 도시명, 주 별 사원의 수를 조회한다.
SELECT LOC.CITY 
     , LOC.STATE_PROVINCE 
     , COUNT(EMP.EMPLOYEE_ID)
  FROM EMPLOYEES EMP
 RIGHT JOIN DEPARTMENTS DEP
    ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID 
 RIGHT JOIN LOCATIONS LOC
    ON LOC.LOCATION_ID = DEP.LOCATION_ID 
 GROUP BY LOC.CITY
     , LOC.STATE_PROVINCE 
;
-- 146. 부서명, 직무명 별 평균 연봉 중 가장 작은 평균연봉을 받는 부서명, 직무명을 조회한다.
SELECT DEPARTMENT_NAME
     , JOB_TITLE
     , SAL
  FROM (SELECT DEPARTMENT_NAME
             , JOB_TITLE
             , SAL
		  FROM (SELECT DEP.DEPARTMENT_NAME 
				     , JOB.JOB_TITLE 
				     , AVG(EMP.SALARY) SAL
				  FROM EMPLOYEES EMP
				  JOIN DEPARTMENTS DEP
				    ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID 
				  JOIN JOBS JOB
				    ON EMP.JOB_ID = JOB.JOB_ID
				 GROUP BY DEP.DEPARTMENT_NAME 
				     , JOB.JOB_TITLE)
		 ORDER BY SAL ASC)
 WHERE ROWNUM < 2
;
-- 147. 102번 직원의 모든 부하직원의 수를 조회한다.
 SELECT COUNT(1) - 1
   FROM EMPLOYEES
  START WITH EMPLOYEE_ID = 102
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;
-- 148. 113번 직원의 모든 부하직원의 수를 조회한다.
 SELECT COUNT(1) - 1
   FROM EMPLOYEES 
  START WITH EMPLOYEE_ID = 113
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;
-- 149. 부하직원이 없는 사원의 모든 정보를 조회한다.
-- LEFT OUTER JOIN을 이용해서, 교집합이 아닌 부분을 가져오기.
SELECT EMP.EMPLOYEE_ID 상사
	 , EMP2.MANAGER_ID "사원의 상사번호"
	 , EMP2.EMPLOYEE_ID 사원
  FROM EMPLOYEES EMP
  LEFT JOIN EMPLOYEES EMP2
    ON EMP.EMPLOYEE_ID = EMP2.MANAGER_ID
 WHERE EMP2.MANAGER_ID IS NULL
;

SELECT *
  FROM EMPLOYEES EMP
 WHERE EMP.EMPLOYEE_ID NOT IN (SELECT EMP2.MANAGER_ID 
 								 FROM EMPLOYEES EMP2
 								WHERE EMP2.MANAGER_ID IS NOT NULL)

-- 150. 사원번호가 100번인 사원의 사원번호, 이름과 사원번호로 내림차순 정렬된 사원의 사원번호, 이름 조회한다.
-- 방법1 CASE
SELECT EMPLOYEE_ID 
     , FIRST_NAME
  FROM (SELECT EMPLOYEE_ID
		     , FIRST_NAME
		     , CASE 
		         WHEN EMPLOYEE_ID = 100 THEN
				   1
			     ELSE
			       2
			    END ORDER_EMP
		  FROM EMPLOYEES
		 ORDER BY ORDER_EMP ASC
		     , EMPLOYEE_ID DESC)
;

--방법 2 UNION ALL
SELECT EMPLOYEE_ID
	 , FIRST_NAME
  FROM EMPLOYEES EMP_100
 WHERE EMP_100.EMPLOYEE_ID = 100
 UNION ALL
SELECT *
  FROM (SELECT EMPLOYEE_ID
			 , FIRST_NAME
		  FROM EMPLOYEES EMP
		 WHERE EMP.EMPLOYEE_ID != 100
		 ORDER BY EMPLOYEE_ID DESC)
;


-- 조회 예
----------------------
-- 100	Steven
-- 206	William
-- 205	Shelley
-- 204	Hermann
-- 203	Susan
-- 202	Pat
-- 201	Michael
-- 200	Jennifer
-- 199	Douglas
-- 198	Donald
-- 197	Kevin
-- 196	Alana
-- ...